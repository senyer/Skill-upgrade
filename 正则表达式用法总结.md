##  正则表达式介绍

正则表达式是一种文本模式，包括普通字符和特殊字符。，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

### 一个简单的例子

``` bash
^[0-9]+abc$
```

* `^`是匹配输入字符串的开始位置
* `[0-9]+` 匹配多个数字，`[0-9]` 表示匹配单个数字。`+` 表示匹配一个或者多个。
* `abc$` 匹配字母`abc` 并以abc结尾，$ 为匹配输入字符串的结束位置。

### 又一个例子

很常见的：用户表单里面用户名只允许包含字符、数字、下划线和链接字符（-） ，并设置用户名长度：

``` bash
^[a-z0-9_-]{3,15}$
```



## 语法

### 很常用的字符！

| 元字符 | 说明                               |
| :----: | ---------------------------------- |
|   .    | 匹配除了换行符以外的任意字符       |
|   \w   | 匹配字幕或者数字或者下划线或者汉字 |
|   \s   | 匹配任意的空白符                   |
|   \d   | 匹配数字                           |
|   \b   | 匹配单词的开始或者结束             |
|   ^    | 匹配字符串的开始                   |
|   $    | 匹配字符串的结束                   |
|   *    | 重复0次或者n次                     |
|   +    | 重复1次或者n次                     |
|   ？   | 重复0次或者1次                     |
|  {n}   | 重复n次                            |
|  {n,}  | 重复n次或者更多次                  |
| {n,m}  | 重复n到m次                         |

1. 匹配有abc开头的字符串：

```java
   \babc或者^abc
```

2. 匹配8位数字的QQ号码：

```java
   ^\d\d\d\d\d\d\d\d$
```

3. 匹配1开头11位数字的手机号码：

```java
   ^1\d\d\d\d\d\d\d\d\d\d$
```

4. 匹配8位数字的QQ号码：

```java
   ^\d{8}$
```

5. 匹配1开头11位数字的手机号码：

```java
   ^1\d{10}$
```

6. 匹配银行卡号是14~18位的数字：

```java
   ^\d{14,18}$
```

7. 匹配以a开头的，0个或多个b结尾的字符串

```java
   ^ab*$
```

> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

**分组的概念**：如果没有括号，就是匹配单个字符，加了括号可以匹配一组。

因此当我们要匹配多个ab时，我们可以这样
如：匹配字符串中包含0到多个ab开头：

```java
   ^(ab)*
```

**条件或的概念**：

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理匹配一个联通号码的问题（因为联通有特定的号段）

```bash
   ^(130|131|132|155|156|185|186|145|176)\d{8}$
```

**区间的概念**：

> 正则提供一个元字符中括号 [] 来表示区间条件。

1. 限定0到9 可以写成[0-9]
2. 限定A-Z 写成[A-Z]
3. 限定某些数字 [165]

那上面的正则我们还改成这样：

```bash
   ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```







------



### 普通字符

包括没有显式指定为元字符（特殊字符）的所有可打印和不可打印的字符。包括所有大小写字母、数字、标点符号等。

### 非打印字符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的 **runoo\*b** 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 **\\**: **runo\\*ob** 匹配 runo*ob。

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | **匹配输入字符串的结尾位置**。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \\$。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 |
| *        | **匹配前面的子表达式零次或多次**。要匹配 * 字符，请使用 \\*。 |
| +        | **匹配前面的子表达式一次或多次**。要匹配 + 字符，请使用 \\+。 |
| .        | **匹配除换行符 \n 之外的任何单字符**。要匹配 . ，请使用 \\. 。 |
| [        | **标记一个中括号表达式的开始**。要匹配 [，请使用 \\[。       |
| ?        | **匹配前面的子表达式零次或一次，或指明一个非贪婪限定符**。要匹配 ? 字符，请使用 \?。 |
| \        | **将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符**。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\\\\' 匹配 "\"，而 '\\(' 则匹配 "("。 |
| ^        | **匹配输入字符串的开始位置**，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | **标记限定符表达式的开始**。要匹配 {，请使用 \\{。           |
| \|       | **指明两项之间的一个选择**。要匹配 \|，请使用 \\             |

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | **匹配前面的子表达式零次或多次**。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | **匹配前面的子表达式一次或多次**。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | **匹配前面的子表达式零次或一次**。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | **n 是一个非负整数。匹配确定的 n 次**。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | **n 是一个非负整数。至少匹配n 次**。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | **m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次**。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

**注意**:	 *  和  +  限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配.

### 定位符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：



### 又有一个例子

| 字符簇           | 描述                            |
| :--------------- | :------------------------------ |
| ^[a-zA-Z_]$      | 所有的字母和下划线              |
| ^[[:alpha:]]{3}$ | 所有的3个字母的单词             |
| ^a$              | 字母a                           |
| ^a{4}$           | aaaa                            |
| ^a{2,4}$         | aa,aaa或aaaa                    |
| ^a{1,3}$         | a,aa或aaa                       |
| ^a{2,}$          | 包含多于两个a的字符串           |
| ^a{2,}           | 如：aardvark和aaab，但apple不行 |
| a{2,}            | 如：baad和aaa，但Nantucket不行  |
| \t{2}            | 两个制表符                      |
| .{2}             | 所有的两个字符                  |



| 正则表达式                                | 描述                                                         |
| :---------------------------------------- | :----------------------------------------------------------- |
| /\b([a-z]+) \1\b/gi                       | 一个单词连续出现的位置。                                     |
| /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/       | 将一个URL解析为协议、域、端口及相对路径。                    |
| /^(?:Chapter\|Section) [1-9][0-9]{0,1}$/  | 定位章节的位置。                                             |
| /[-a-z]/                                  | a至z共26个字母再加一个-号。                                  |
| /ter\b/                                   | 可匹配chapter，而不能匹配terminal。                          |
| /\Bapt/                                   | 可匹配chapter，而不能匹配aptitude。                          |
| /Windows(?=95 \|98 \|NT )/                | 可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。 |
| /^\s*$/                                   | 匹配空行。                                                   |
| /\d{2}-\d{5}/                             | 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。        |
| /<\s*(\S+)(\s[^>]*)?>[\s\S]*<\s*\/\1\s*>/ | 匹配 HTML 标记。                                             |
